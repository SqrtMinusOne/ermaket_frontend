<template>
  <ag-grid-vue
    :columnDefs="columnDefs"
    :gridOptions="gridOptions"
    @grid-ready="onGridReady"
    @cell-value-changed="onValueChanged"
    @pagination-changed="onModelUpdated"
    @sort-changed="onTableSortChanged"
    @filter-changed="onTableFilterChanged"
    class="ag-theme-material"
    ref="table"
  />
</template>

<script lang="ts">
import { Component, Model, Prop, Vue, Watch } from 'vue-property-decorator'
import { AgGridVue } from 'ag-grid-vue'
import {
  CellValueChangedEvent,
  ColDef,
  ColumnApi,
  GridApi,
  GridOptions,
  GridReadyEvent,
  IDatasource,
  IGetRowsParams,
  RowNode,
} from 'ag-grid-community'
import _ from 'lodash'

import { instanceOfLinkedColumn, instanceOfTable } from '@/types/user_guards'
import { Column, LinkedColumn, Table, TableLinkType } from '@/types/user'
import { Criterion, FilterObject, Operator, Order } from '@/types/tables'
import { tableMapper } from '@/store/modules/table'
import { userMapper } from '@/store/modules/user'

import BootstrapEditor from './table/bootstrap_editor'
import CheckboxRenderer from './table/checkbox_renderer'
import DatePickerEditor from './table/datepicker_editor'
import LinkedEditor, { MakeLinkedSelectSetter } from './table/linked_editor'
import LinkedRenderer from './table/linked_renderer'
import LinkedTableRenderer from './table/linked_table'
import TableHeader from './table/header'
import TimestampRenderer from './table/timestamp_renderer'

const Mappers = Vue.extend({
  computed: {
    ...tableMapper.mapState(['loaded', 'transaction']),
    ...userMapper.mapGetters(['hierarchyElem']),
  },
  methods: {
    ...tableMapper.mapActions(['fetchRows', 'setRecordUpdate', 'setRowUpdate']),
  },
  name: 'TableComponent',
})

@Component({
  components: {
    AgGridVue,
  },
})
export default class TableComponent extends Mappers {
  public gridApi?: GridApi
  public columnApi?: ColumnApi

  @Prop({ type: Boolean, default: false }) public readonly autoLoadLinked!: boolean

  @Prop({ type: Number, required: true }) private readonly id!: number
  @Prop({ type: Boolean, default: false }) private fill!: boolean
  @Prop({ type: Object }) private readonly filterModel?: FilterObject
  @Prop({ type: Object }) private readonly sortModel?: Order
  @Prop({ type: Boolean, default: false }) private readonly noEdit!: boolean
  @Prop({ type: Object }) private readonly keysParams?: {
    edit: boolean
    column: LinkedColumn
  }

  @Model('change', { type: Array }) readonly keys?: any[]

  private error?: string
  private onResize: any
  private linkedOpened: {
    [key: string]: LinkedColumn
    [key: number]: LinkedColumn
  } = {}
  private resetHeight: boolean = false
  private defaultRowHeight: number = 48

  private gridOptions: GridOptions = {
    rowModelType: 'infinite',
    rowBuffer: 20,
    paginationPageSize: 100,
    pagination: true,
    frameworkComponents: {
      BootstrapEditor,
      CheckboxRenderer,
      DatePickerEditor,
      LinkedEditor,
      LinkedRenderer,
      LinkedTableRenderer,
      TimestampRenderer,
      agColumnHeader: TableHeader,
    },
    multiSortKey: 'ctrl',
    context: {
      parent: this,
    },
    fullWidthCellRenderer: 'LinkedTableRenderer',
    isFullWidthCell: this.isFullWidth,
    getRowHeight: this.getRowHeight,
    headerHeight: 40,
  }

  public onLinkedTable(key: any, column: LinkedColumn) {
    this.linkedOpened[key] = column
    if (this.gridApi) {
      this.gridApi.refreshInfiniteCache()
    }
  }

  public onLinkedClose(key: any) {
    delete this.linkedOpened[key]
    this.resetHeight = true
    if (this.gridApi) {
      this.gridApi.refreshInfiniteCache()
    }
  }

  public getLinked(key: any) {
    return this.linkedOpened[key]
  }

  public setRowsHeight() {
    let gridHeight = 0
    let clipperHeight = 0
    if (!this.gridOptions.api) {
      return
    }

    const startIndex =
      this.gridOptions.api.paginationGetCurrentPage() *
      this.gridOptions.api.paginationGetPageSize()
    const endIndex = startIndex + this.gridOptions.api.paginationGetPageSize()
    this.gridOptions.api.forEachNode((node: RowNode) => {
      let rowHeight
      if (node.rowIndex >= startIndex && node.rowIndex < endIndex) {
        rowHeight = (this.gridOptions.getRowHeight as any)(node)
        clipperHeight += rowHeight
      } else {
        rowHeight = this.defaultRowHeight
      }
      node.setRowHeight(rowHeight)
      node.setRowTop(gridHeight)
      gridHeight += rowHeight
    })
    if (!gridHeight) {
      return
    }

    const elements = this.$el.getElementsByClassName(
      'ag-center-cols-container'
    ) as any
    if (elements) {
      elements[0].style.height = `${gridHeight}px`
    }

    const clippers = this.$el.getElementsByClassName(
      'ag-center-cols-clipper'
    ) as any
    if (clippers) {
      clippers[0].style.height = `${clipperHeight}px`
    }
  }

  private getRowHeight(node: RowNode) {
    if (this.isFullWidth(node)) {
      return 350
    }
    return this.defaultRowHeight
  }

  private onModelUpdated() {
    if (this.resetHeight || !_.isEmpty(this.linkedOpened)) {
      this.setRowsHeight()
      this.resetHeight = false
    }
  }

  private isFullWidth(row: RowNode) {
    return Boolean(row.data && row.data._linked)
  }

  @Watch('id')
  private onIdChanged() {
    this.initTable()
  }

  @Watch('filterModel')
  private onFilterChanged() {
    if (this.gridApi) {
      this.gridApi.setFilterModel(this.filterModel)
    }
  }

  @Watch('sortModel')
  private onSortChanged() {
    if (this.gridApi) {
      this.gridApi.setSortModel(this.sortModel)
    }
  }

  @Watch('keysParams', { deep: true })
  private onKeysParamsChanged() {
    if (this.gridApi) {
      this.gridApi.refreshInfiniteCache()
    }
  }

  @Watch('autoLoadLinked')
  private onAutoLoadLinkedChanged() {
    if (this.gridApi) {
      this.gridApi.refreshCells({ force: true })
    }
  }

  private onTableSortChanged() {
    this.$emit('modelsChanged')
  }

  private onTableFilterChanged() {
    this.$emit('modelsChanged')
  }

  private created() {
    this.onResize = this.setTableHeight.bind(this)
  }

  private onGridReady(params: GridReadyEvent) {
    this.gridApi = params.api
    this.columnApi = params.columnApi
    this.initTable()
    if (this.fill) {
      this.setTableHeight()
      window.addEventListener('resize', this.onResize, { passive: true })
    }
  }

  private get elem(): Table {
    return this.hierarchyElem(this.id) as Table
  }

  private get pk(): Column {
    return this.elem.columns.find((col) => col.isPk) as Column
  }

  private initTable() {
    const elem = this.elem
    this.linkedOpened = {}
    this.gridOptions.fullWidthCellRendererParams = {
      table: this.elem as Table,
      pk: this.pk,
    }
    if (!instanceOfTable(elem)) {
      this.error = 'This table does not exist'
      return
    }
    this.gridOptions.paginationPageSize = elem.linesOnPage
    if (this.gridApi) {
      if (!_.isEmpty(this.gridApi.getFilterModel())) {
        this.gridApi.setFilterModel(null)
      }
      if (!_.isEmpty(this.gridApi.getSortModel())) {
        this.gridApi.setSortModel(null)
      }
      this.gridApi.setDatasource(this.makeDataSource())
      if (this.filterModel) {
        this.gridApi.setFilterModel(this.filterModel)
      }
      if (this.sortModel) {
        this.gridApi.setSortModel(this.sortModel)
      }
    }
    if (this.columnApi) {
      this.columnApi.resetColumnState()
    }
  }

  private setTableHeight() {
    if (this.fill) {
      window.scrollTo(0, 0)
      const element = this.$el as any
      const viewport = element.getBoundingClientRect()
      const height = window.innerHeight - viewport.top - 20
      element.style.height = `${height}px`
    }
  }

  private beforeDestroy() {
    window.removeEventListener('resize', this.onResize)
  }

  private get columnDefs(): ColDef[] {
    const defs: ColDef[] = []
    const table = this.elem
    if (!table) {
      return defs
    }
    const pk = this.pk
    if (this.keys && this.keysParams && this.keysParams.edit) {
      defs.push({
        headerName: this.keysParams.column.text,
        field: '_key',
        resizable: true,
        sortable: false,
        lockPinned: true,
        pinned: 'left',
        filter: false,
        headerComponentParams: { isPk: false, table, pk },
        cellRendererParams: { table, pk },
        cellRenderer: 'CheckboxRenderer',
        editable: false,
      })
    }
    for (const column of table.columns) {
      const def: ColDef = {
        headerName: column.text,
        field: column.rowName,
        resizable: true,
        sortable: column.isSort && Boolean(column.type),
        filter: this.getFilter(column),
        headerComponentParams: {
          isPk: column.isPk,
          columnElem: column,
          table,
          pk,
        },
        cellRendererParams: { columnElem: column, table, pk },
        cellRenderer: this.getRenderer(column),
        editable: this.getIsEditable(column),
        ...this.getEditor(column, table),
      }
      defs.push(def)
    }
    return defs
  }

  private getIsEditable(column: Column) {
    if (this.noEdit) {
      return false
    }
    if (!instanceOfLinkedColumn(column)) {
      return column.isEditable
    }
    if (column.linkType !== TableLinkType.linked) {
      return column.isEditable
    }
    return false
  }

  private getRenderer(column: Column) {
    if (instanceOfLinkedColumn(column)) {
      return 'LinkedRenderer'
    }
    switch (column.type) {
      case 'date':
      case 'time':
      case 'timestamp':
        return 'TimestampRenderer'
    }
    return undefined
  }

  private getEditor(column: Column, table: Table) {
    const pk = this.pk
    const params = { columnElem: column, table, pk }

    if (instanceOfLinkedColumn(column)) {
      const valueSetter = MakeLinkedSelectSetter(
        column,
        (key: any, data: any, index?: number) => {
          this.setRecordUpdate({ id: table.id, key, data, index })
        },
        pk
      )
      switch (column.linkType) {
        case TableLinkType.linked:
          return
        case TableLinkType.simple:
        case TableLinkType.dropdown:
          return {
            cellEditor: 'LinkedEditor',
            cellEditorParams: params,
            valueSetter,
          }
      }
    }

    if (column.type && column.type.startsWith('enum')) {
      const opts = column.type
        .slice(5, -1)
        .split(',')
        .map((attr) => attr.trim().slice(1, -1))
      return {
        cellEditor: 'agSelectCellEditor',
        cellEditorParams: {
          ...params,
          values: opts,
        },
      }
    }

    switch (column.type) {
      case 'text':
        return {
          cellEditor: 'agLargeTextCellEditor',
          cellEditorParams: params,
        }
      case 'timestamp':
        return {
          cellEditor: 'DatePickerEditor',
          cellEditorParams: params,
        }
      default:
        return {
          cellEditor: 'BootstrapEditor',
          cellEditorParams: params,
        }
    }
  }

  private getFilter(column: Column | LinkedColumn) {
    if (!column.type) {
      return false
    }
    if (column.type.match(/((float|int)\d*|bool|decimal.*)/)) {
      return 'agNumberColumnFilter'
    }
    if (column.type.match(/(date|timestamp)/)) {
      return 'agDateColumnFilter'
    }
    return 'agTextColumnFilter'
  }

  private onValueChanged(event: CellValueChangedEvent) {
    if (event.oldValue === undefined && event.newValue === undefined) {
      return
    }
    this.setRowUpdate({ id: this.id, index: event.rowIndex, data: event.data })
  }

  private makeDataSource(): IDatasource {
    const self = this
    return {
      rowCount: undefined,
      getRows(params: IGetRowsParams) {
        const filter = self.castFilterModel(params.filterModel)
        const order = self.castSortModel(params.sortModel)
        const payload = {
          id: self.id,
          rowStart: params.startRow,
          rowEnd: params.endRow,
          filter,
          order,
        }
        self
          .fetchRows(payload)
          .then((data) => {
            data = _.cloneDeep(data)
            if (!filter && self.loaded[self.id]) {
              this.rowCount = self.loaded[self.id].rowCount
            } else {
              if (data.length < params.endRow - params.startRow) {
                this.rowCount = params.startRow + data.length
              } else {
                this.rowCount = undefined
              }
            }
            self.injectIndices(data, params.startRow)
            if (!_.isEmpty(self.linkedOpened)) {
              data = self.injectLinkedRows(data)
            }
            if (self.keys && self.keysParams && self.keysParams.edit) {
              data = self.injectKeys(data)
            }
            params.successCallback(data, this.rowCount)
          })
          .catch((err) => {
            console.error(err)
            params.failCallback()
          })
      },
    }
  }

  private castSortModel(model: any[]): Order | undefined {
    if (model.length === 0) {
      return
    }
    return model.map((sort: any) => {
      const column = (this.columnApi as ColumnApi)
        .getColumn(sort.colId)
        .getUserProvidedColDef().cellRendererParams.columnElem as Column
      if (sort.sort === 'asc') {
        return column.rowName
      } else {
        return `-${column.rowName}`
      }
    })
  }

  private castFilterModel(model: any): FilterObject | undefined {
    const obj: any = {
      and: [],
      or: [],
    }
    for (const [column, filter] of Object.entries(model)) {
      const { and, or } = this.castFilterColumn(column, filter)
      if (and) {
        obj.and.push(...and)
      }
      if (or) {
        obj.or.push(...or)
      }
    }
    if (this.keys && this.keysParams && !this.keysParams.edit) {
      obj.or.push(...this.addKeysFilter())
    }
    if (obj.and.length + obj.or.length === 0) {
      return undefined
    }
    return obj
  }

  private castFilterColumn(column: string, filter: any): FilterObject {
    if ('operator' in filter) {
      const noRange = filter.operator === 'or'
      const conditions = [
        ...this.castCondition(column, filter.condition1, noRange),
        ...this.castCondition(column, filter.condition2, noRange),
      ]
      if (filter.operator === 'AND') {
        return {
          and: conditions,
        }
      } else {
        return {
          or: conditions,
        }
      }
    } else {
      return { and: this.castCondition(column, filter) }
    }
  }

  private addKeysFilter(): Criterion[] {
    if (this.keys) {
      return this.keys.map((key) => {
        return {
          field_name: this.pk.rowName,
          operator: Operator.equals,
          field_value: key,
        }
      })
    }
    return []
  }

  private castCondition(
    column: string,
    condition: any,
    noRange: boolean = false
  ): Criterion[] {
    const operators = {
      equals: Operator.equals,
      notEqual: Operator.not_equals,
      contains: Operator.icontains,
      startsWith: Operator.istartswith,
      endsWith: Operator.iendswith,
      lessThan: Operator.less_than,
      lessThanOrEqual: Operator.less_than_equals,
      greaterThan: Operator.greater_than,
      greaterThanOrEqual: Operator.greater_than_equals,
      empty: Operator.isnotnull,
    }
    if (condition.type === 'inRange' && !noRange) {
      return [
        {
          field_name: column,
          operator: Operator.greater_than_equals,
          field_value: condition.filter || condition.dateFrom,
        },
        {
          field_name: column,
          operator: Operator.less_than_equals,
          field_value: condition.filterTo || condition.dateTo,
        },
      ]
    } else if (condition.type === 'inRange' && noRange) {
      this.error = 'Range is not supported with OR'
    }
    const op = operators[condition.type as keyof typeof operators]
    if (op === undefined) {
      this.error = `Operator ${condition.type} is not supported`
      console.warn(this.error)
      return []
    }
    return [
      {
        field_name: column,
        operator: op,
        field_value: condition.filter || condition.dateFrom,
      },
    ]
  }

  private injectIndices(data: any[], start: number) {
    for (const i in data) {
      data[i]._index = start + Number(i)
    }
  }

  private injectLinkedRows(data: any[]): any[] {
    const newData: any = []
    for (const datum of data) {
      newData.push(datum)
      const col = this.linkedOpened[datum[this.pk.rowName]]
      if (col) {
        newData.push({ ...datum, _linked: col })
      }
    }
    return newData
  }

  private injectKeys(data: any[]): any[] {
    const keys = new Set(this.keys)
    return data.map((datum) => {
      if (keys.has(datum[this.pk.rowName])) {
        return { _key: true, ...datum }
      }
      return { _key: false, ...datum }
    })
  }
}
</script>

<style lang="scss"></style>
